<?php 
// $Id: feedapi_parser_exhaustive.module,v 1.10 2009/05/28 19:01:29 e2thex Exp $
/*
 * implimentation of hook_feedapi_feed
 */
function feedapi_parser_exhaustive_feedapi_feed($op, $feed, $somthing) {
  $args = func_get_args();
  if ($op=='type') {
   return array("XML feed");
  }
  if ($op=='compatible') {
   return "XML feed";

  }
  if ($op=='parse') {

    if (is_string($feed->url)) {
      $ch = curl_init($feed->url);
    }   
    else {
      $ch = curl_init($feed->settings['feedapi_url']);
    }       
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
    curl_setopt($ch, CURLOPT_HEADER, 0);
    $data = curl_exec($ch);
    curl_close($ch);
    $feed_full_DOM = new DOMDocument('1.0');
    $feed_full_DOM->loadXML($data);  

    // Set var if feed is RSS
    $channels= $feed_full_DOM->getElementsByTagName("channel");
    $item_tag='item';
    foreach ($channels as $feed_dom) {
      $feed_array =_feedapi_parser_exhaustive_DOM_to_array($feed_dom);
    }
    // Set vars if feed is Atom
    if (!$feed_array) {
      $feed_tag= $feed_full_DOM->getElementsByTagName("feed");
      $item_tag='entry';
      foreach ($feed_tag as $feed_dom) {
        $feed_array =_feedapi_parser_exhaustive_DOM_to_array($feed_dom);
      }
    }
    // get feed_elements
    $feed_elements_array = array_diff_key($feed_array, array( $item_tag => 1 ));
    $feed_elements = new stdClass;
    $feed_elements = _feedapi_parser_exhaustive_array_to_object_for_feed_api($feed_elements_array);
    
    // get item elements
    $parsed_source = new stdClass();
    $parsed_source->items = array();
    if ($feed_items = $feed_array[$item_tag]) {
      foreach ($feed_items as $item_array) {
        $item = new stdClass;
        $item->options = new stdClass;
        $item->options->all = _feedapi_parser_exhaustive_array_to_object_for_feed_api($item_array);
        $item->options->feed_elements = $feed_elements;
        $parsed_source->items[] = $item;
      }
    }
    return $parsed_source;
   }

}

/*
 * converts an array created by _feedapi_parser_exhaustive_DOM_to_array into the 
 * object expected from a feed apo parser
 * @PARAM $array : an array generated by _feedapi_parser_exhaustive_DOM_to_array
 * @RETURN : stdClass object
 */
function _feedapi_parser_exhaustive_array_to_object_for_feed_api($array) {
  if (!is_array($array)) {
    return $array;
  }
  else if (_feedapi_parser_exhaustive_is_assoc($array)) {
    $r = new stdClass();
    foreach ($array as $key => $value) {
      $r->{$key} = _feedapi_parser_exhaustive_array_to_object_for_feed_api($value);
    }
    return $r;
  }
  else {
    foreach ($array as $key => $value) {
      $r[] = _feedapi_parser_exhaustive_array_to_object_for_feed_api($value);
    }
    return $r;
  }
}

/*
 * converts a DOMNode to an array 
 * @PARAM $node : a DOMNode object
 * @RETURN : an array
 * for 
 * <item>
 *   <name href="http://google.com">Joe</name>
 *   <cat>baseball</cat>
 *   <cat>softball</cat>
 * </item>
 * on would get
 * array( 
 *   'name' => array( 
 *     '@href' = "http://google.com",
 *     '#text' = "Joe"
 *   ),
 *   'cat' = array(
 *     'baseball',
 *     'softball,
 *   ),
 * )
 *
 */
function _feedapi_parser_exhaustive_DOM_to_array($node, $rec_call = FALSE) {
  // if the node has children iterate through them and call the parse fuction on the children.
  $l =$node->childNodes->length;
  if ($node->hasChildNodes()) {
    $l =$node->childNodes->length;
    for ($i=0;$i<$l;$i++)  {
      $c_node = $node->childNodes->item($i);
      $r[$c_node->nodeName][] = _feedapi_parser_exhaustive_DOM_to_array($node->childNodes->item($i), TRUE);
    }
    foreach ($r as $key => $value) {
      if (is_array($value) && sizeof($value) == 1) {
        $r[$key] = $value[0];
      }
      else{
        foreach ($value as $item_index => $item) {

          if (is_array($item) && sizeof($item) ==1 && array_key_exists('#text', $item)) {
            $r[$key][$item_index] = $item['#text'];
          }
        }
      }
    }
    // if the array hasmore then one element remove the #text element (this tend to be added with wierd amounts of spaces
    if (sizeof($r)>1) {
      $r = array_diff_key($r, array('#text' => 1));
    }
    // if the node has attributes add them to the array with a @ prefix
    if ($node->hasAttributes()) {
      foreach ($node->attributes as $attr_node) {
       $r['@'. $attr_node->name] = $attr_node->value;
      }
    }
  }
  else {
   if ($node->hasAttributes()) {
     foreach ($node->attributes as $attr_node) {
       $r['@'. $attr_node->name] = $attr_node->value;
     }
     $r['#text'] = $node->nodeValue;
   } else {
     $r= $node->nodeValue;
   }
  }
  if ($rec_call ===FALSE) { 
  }
  return $r;
}

/*
 * Check to see if an item is an hash
 * @PARAM : $var a variable
 * @RETURN : bool
 */
function _feedapi_parser_exhaustive_is_assoc($var) {
  return is_array($var) && array_diff_key($var, array_keys(array_keys($var)));
}


